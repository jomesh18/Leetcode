'''
382. Linked List Random Node
Medium

1342

332

Add to List

Share
Given a singly linked list, return a random node's value from the linked list. Each node must have the same probability of being chosen.

Implement the Solution class:

Solution(ListNode head) Initializes the object with the integer array nums.
int getRandom() Chooses a node randomly from the list and returns its value. All the nodes of the list should be equally likely to be choosen.
 

Example 1:


Input
["Solution", "getRandom", "getRandom", "getRandom", "getRandom", "getRandom"]
[[[1, 2, 3]], [], [], [], [], []]
Output
[null, 1, 3, 2, 2, 3]

Explanation
Solution solution = new Solution([1, 2, 3]);
solution.getRandom(); // return 1
solution.getRandom(); // return 3
solution.getRandom(); // return 2
solution.getRandom(); // return 2
solution.getRandom(); // return 3
// getRandom() should return either 1, 2, or 3 randomly. Each element should have equal probability of returning.
 

Constraints:

The number of nodes in the linked list will be in the range [1, 104].
-104 <= Node.val <= 104
At most 104 calls will be made to getRandom.
 

Follow up:

What if the linked list is extremely large and its length is unknown to you?
Could you solve this efficiently without using extra space?
Accepted
127,491
Submissions
224,043
'''

# Definition for singly-linked list.
# O(n), O(n)
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

# class Solution:

#     def __init__(self, head):
#         self.head = head
#         self.arr = []
#         curr = self.head
#         while curr:
#             self.arr.append(curr)
#             curr = curr.next
#         self.n = len(self.arr)
        
#     def getRandom(self) -> int:
#         return self.arr[random.randint(0, self.n-1)].val


#using reservoir sampling, O(n), O(1)
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:

    def __init__(self, head):
        self.head = head
        
    def getRandom(self) -> int:
        k = 1
        arr = [0] * k
        curr = self.head
        count = 0
        while count < k:
            arr[count] = curr.val
            curr = curr.next
            count += 1
        while curr:
            n = random.randint(0, count)
            if n < k:
                arr[n] = curr.val
            count += 1
        return arr[0]


class Solution:
    def __init__(self, head: ListNode):
        """
        @param head The linked list's head.
        Note that the head is guaranteed to be not null, so it contains at least one node.
        """
        self.head = head

    def getRandom(self) -> int:
        """
        Returns a random node's value.
        """
        scope = 1
        chosen_value = 0
        curr = self.head

        while curr:
            # decide whether to include the element in reservoir
            if random.random() < 1 / scope:
                chosen_value = curr.val
            # move on to the next node
            curr = curr.next
            scope += 1
        return chosen_value

# Your Solution object will be instantiated and called as such:
# obj = Solution(head)
# param_1 = obj.getRandom()

null = None

inp1 = ["Solution", "getRandom", "getRandom", "getRandom", "getRandom", "getRandom"]
inp2 = [[[1, 2, 3]], [], [], [], [], []]
Output = [null, 1, 3, 2, 2, 3]

obj = Solution(inp2[0])

res = [None]

for para1, para2 in zip(inp1, inp2):
    if para1 == 'getRandom':
        res.append(obj.getRandom())

print(res)
print(Output)
print(Output == res)
